import os
import requests
import re
from datetime import datetime

def get_org_repos(org_name, token):
    """Fetch all public repositories for the organization"""
    headers = {
        'Authorization': f'token {token}',
        'Accept': 'application/vnd.github.v3+json'
    }

    repos = []
    page = 1

    while True:
        url = f'https://api.github.com/orgs/{org_name}/repos'
        params = {
            'type': 'public',
            'sort': 'updated',
            'direction': 'desc',
            'per_page': 100,
            'page': page
        }

        response = requests.get(url, headers=headers, params=params)

        if response.status_code != 200:
            print(f"Error fetching repos: {response.status_code}")
            break

        page_repos = response.json()

        if not page_repos:
            break

        repos.extend(page_repos)
        page += 1

    return repos

def format_repo_list(repos, max_repos=30):
    """Format repositories as markdown"""
    repo_list = []

    # Sort by stars (most popular first)
    repos.sort(key=lambda x: x.get('stargazers_count', 0), reverse=True)

    # Take top repos
    top_repos = repos[:max_repos]

    for repo in top_repos:
        name = repo['name']
        description = repo['description'] or 'No description'
        stars = repo['stargazers_count']
        language = repo['language'] or 'Unknown'
        url = repo['html_url']

        # Truncate description if too long
        if len(description) > 100:
            description = description[:97] + '...'

        repo_entry = f"- [{name}]({url}) - {description} `{language}` ‚≠ê {stars}"
        repo_list.append(repo_entry)

    return '\n'.join(repo_list)

def format_stats(repos):
    """Generate organization statistics"""
    total_stars = sum(repo.get('stargazers_count', 0) for repo in repos)
    total_forks = sum(repo.get('forks_count', 0) for repo in repos)

    languages = {}
    for repo in repos:
        lang = repo.get('language')
        if lang:
            languages[lang] = languages.get(lang, 0) + 1

    top_languages = sorted(languages.items(), key=lambda x: x[1], reverse=True)[:5]

    stats = f"""
### üìä Organization Statistics

- **Total Repositories:** {len(repos)}
- **Total Stars:** ‚≠ê {total_stars:,}
- **Total Forks:** üç¥ {total_forks:,}
- **Top Languages:** {', '.join([f'{lang} ({count})' for lang, count in top_languages])}
"""
    return stats

def update_readme(repos, org_name):
    """Update README.md with repository list"""

    # Read current README
    with open('README.md', 'r', encoding='utf-8') as f:
        readme = f.read()

    # Generate new content
    repo_list = format_repo_list(repos)
    stats = format_stats(repos)

    new_content = f"""<!-- REPO-LIST:START -->
<!-- This section is automatically generated by GitHub Actions -->
<!-- Last updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')} -->

{stats}

### üöÄ Popular Repositories

{repo_list}

### View All

üëâ [View all {len(repos)} repositories](https://github.com/orgs/{org_name}/repositories)

<!-- REPO-LIST:END -->"""

    # Replace content between markers or append if markers don't exist
    pattern = r'<!-- REPO-LIST:START -->.*?<!-- REPO-LIST:END -->'

    if re.search(pattern, readme, re.DOTALL):
        # Replace existing content
        new_readme = re.sub(pattern, new_content, readme, flags=re.DOTALL)
    else:
        # Append to end of file
        new_readme = readme + '\n\n' + new_content

    # Write updated README
    with open('README.md', 'w', encoding='utf-8') as f:
        f.write(new_readme)

    print(f"README updated with {len(repos)} repositories")

def main():
    token = os.environ.get('GITHUB_TOKEN')
    org_name = os.environ.get('ORG_NAME')

    if not token or not org_name:
        print("Missing GITHUB_TOKEN or ORG_NAME environment variables")
        return

    print(f"Fetching repositories for organization: {org_name}")
    repos = get_org_repos(org_name, token)

    if repos:
        update_readme(repos, org_name)
    else:
        print("No repositories found or error occurred")

if __name__ == '__main__':
    main()
